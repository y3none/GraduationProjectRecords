## littlefs 技术规范

这是 littlefs 文件系统的技术规范，磁盘版本为 lfs2.1。本文档涵盖了 littlefs 在磁盘上存储的技术细节，以便进行内省和工具开发。本文档假设您已经熟悉 littlefs 的设计，如需了解更多关于 littlefs 的工作原理，请查看 [DESIGN.md](./docs/技术文档/littlefs_DESIGN_zh.md)。

```
   | | |     .---._____
  .-----.   |          |
--|o    |---| littlefs |
--|     |---|          |
  '-----'   '----------'
   | | |
```

## 一些快速说明

- littlefs 是一个基于块的文件系统。磁盘被划分为大小均匀的块数组，这些块用作存储的逻辑单元。

- 块指针以 32 位存储，特殊值 `0xffffffff` 表示空块地址。

- 除了逻辑块大小（通常与擦除块大小匹配）外，littlefs 还使用编程块大小和读取块大小。这些决定了块设备操作的对齐方式，但为了可移植性，不需要保持一致。

- 默认情况下，littlefs 中的所有值都以小端字节序存储。

## 目录 / 元数据对

元数据对构成了 littlefs 的骨干，并提供了一个用于分布式原子更新的系统。甚至超级块也存储在一个元数据对中。

正如其名称所示，一个元数据对存储在两个块中，其中一个块在擦除周期中提供备份，以防止断电时数据丢失。这两个块不一定是连续的，可能位于磁盘的任何位置，因此元数据对的“指针”存储为两个块指针。

此外，每个元数据块的行为类似于可追加的日志，包含可变数量的提交（commits）。可以将提交追加到元数据日志中，以便在不需擦除周期的情况下更新元数据。请注意，连续的提交可能会取代之前提交中的元数据。只有最新的元数据才应被视为有效。

元数据块的高级布局相当简单：

```
  .---------------------------------------.
.-|  revision count   |      entries      |  \
| |-------------------+                   |  |
| |                                       |  |
| |                                       |  +-- 1st commit
| |                                       |  |
| |                   +-------------------|  |
| |                   |        CRC        |  /
| |-------------------+-------------------|
| |                entries                |  \
| |                                       |  |
| |                                       |  +-- 2nd commit
| |    +-------------------+--------------|  |
| |    |        CRC        |    padding   |  /
| |----+-------------------+--------------|
| |                entries                |  \
| |                                       |  |
| |                                       |  +-- 3rd commit
| |         +-------------------+---------|  |
| |         |        CRC        |         |  /
| |---------+-------------------+         |
| |           unwritten storage           |  more commits
| |                                       |       |
| |                                       |       v
| |                                       |
| |                                       |
| '---------------------------------------'
'---------------------------------------'
```

每个元数据块包含一个 32 位的修订计数（revision count），后面跟着若干个提交（commits）。每个提交包含可变数量的元数据条目（metadata entries），最后是一个 32 位的 CRC（循环冗余校验）。

需要注意的是，条目（entries）不一定是字对齐的。这使我们能够更紧凑地存储元数据，但我们只能写入与编程块大小对齐的地址。这意味着每个提交可能包含用于对齐的填充（padding）。

元数据块的字段：

1. **修订计数（32 位）** - 每次擦除周期递增。如果两个块都包含有效的提交，则只应使用具有最新修订计数的块。必须使用序列比较来避免整数溢出的问题。

2. **CRC（32 位）** - 用于检测因断电或其他写入问题导致的损坏。使用 CRC-32，多项式为 `0x04c11db7`，初始值为 `0xffffffff`。

条目本身存储为一个 32 位的标签（tag），后跟一个可变长度的数据块（blob）。但这些标签的存储方式有些复杂。

元数据块支持正向和反向迭代。为了在不重复每个标签空间的情况下实现这一点，相邻条目的标签会进行异或（XOR）操作，起始值为 `0xffffffff`。

```
 Forward iteration                        Backward iteration

.-------------------.  0xffffffff        .-------------------.
|  revision count   |      |             |  revision count   |
|-------------------|      v             |-------------------|
|      tag ~A       |---> xor -> tag A   |      tag ~A       |---> xor -> 0xffffffff
|-------------------|      |             |-------------------|      ^
|       data A      |      |             |       data A      |      |
|                   |      |             |                   |      |
|                   |      |             |                   |      |
|-------------------|      v             |-------------------|      |
|      tag AxB      |---> xor -> tag B   |      tag AxB      |---> xor -> tag A
|-------------------|      |             |-------------------|      ^
|       data B      |      |             |       data B      |      |
|                   |      |             |                   |      |
|                   |      |             |                   |      |
|-------------------|      v             |-------------------|      |
|      tag BxC      |---> xor -> tag C   |      tag BxC      |---> xor -> tag B
|-------------------|                    |-------------------|      ^
|       data C      |                    |       data C      |      |
|                   |                    |                   |    tag C
|                   |                    |                   |
|                   |                    |                   |
'-------------------'                    '-------------------'
```

以下是一个更完整的元数据块示例，其中包含 4 个条目：

```
  .---------------------------------------.
.-|  revision count   |      tag ~A       |        \
| |-------------------+-------------------|        |
| |                 data A                |        |
| |                                       |        |
| |-------------------+-------------------|        |
| |      tag AxB      |       data B      | <--.   |
| |-------------------+                   |    |   |
| |                                       |    |   +-- 1st commit
| |         +-------------------+---------|    |   |
| |         |      tag BxC      |         | <-.|   |
| |---------+-------------------+         |   ||   |
| |                 data C                |   ||   |
| |                                       |   ||   |
| |-------------------+-------------------|   ||   |
| |     tag CxCRC     |        CRC        |   ||   /
| |-------------------+-------------------|   ||
| |     tag CRCxA'    |      data A'      |   ||   \
| |-------------------+                   |   ||   |
| |                                       |   ||   |
| |              +-------------------+----|   ||   +-- 2nd commit
| |              |     tag CRCxA'    |    |   ||   |
| |--------------+-------------------+----|   ||   |
| | CRC          |        padding         |   ||   /
| |--------------+----+-------------------|   ||
| |     tag CRCxA''   |      data A''     | <---.  \
| |-------------------+                   |   |||  |
| |                                       |   |||  |
| |         +-------------------+---------|   |||  |
| |         |     tag A''xD     |         | < |||  |
| |---------+-------------------+         |  ||||  +-- 3rd commit
| |                data D                 |  ||||  |
| |                             +---------|  ||||  |
| |                             |   tag Dx|  ||||  |
| |---------+-------------------+---------|  ||||  |
| |CRC      |        CRC        |         |  ||||  /
| |---------+-------------------+         |  ||||
| |           unwritten storage           |  ||||  more commits
| |                                       |  ||||       |
| |                                       |  ||||       v
| |                                       |  ||||
| |                                       |  ||||
| '---------------------------------------'  ||||
'---------------------------------------'    |||'- most recent A
                                             ||'-- most recent B
                                             |'--- most recent C
                                             '---- most recent D
```

2. 在深入讨论标签编码的细节之前，有两点需要注意：
   
   1.  每个标签包含一个有效位，用于指示标签及其所属的提交是否有效。在异或操作后，该位应始终为零。
      
      在每个提交的末尾，前一个标签的有效位会与 CRC 标签类型字段的最低位进行异或操作。这样，如果下一个提交尚未写入，CRC 标签可以强制下一个提交的有效位检查失败。
      
   2. 由于我们不知道编程块中的位写入顺序，因此仅凭有效位无法确定下一个提交是否被擦除。有可能在尝试编程时，有效位保持不变。
      
      为了确保我们只对已擦除的字节进行编程，每个提交可以包含一个可选的前向 CRC（FCRC）。FCRC 包含在擦除时对下一个提交中某些字节的校验和。
      
      ```
      .-------------------. \      \
      |  revision count   | |      |
      |-------------------| |      |
      |     metadata      | |      |
      |                   | +---.  +-- current commit
      |                   | |   |  |
      |-------------------| |   |  |
      |       FCRC       ---|-. |  |
      |-------------------| / | |  |
      |        CRC       -----|-'  /
      |-------------------|   |
      |      padding      |   |        padding (does't need CRC)
      |                   |   |
      |-------------------| \ |    \
      |      erased?      | +-'    |
      |         |         | |      +-- next commit
      |         v         | /      |
      |                   |        /
      |                   |
      '-------------------'
      ```
      
      如果 FCRC 缺失或校验和不匹配，我们必须假设尝试了一个提交但由于断电而失败。
      
      需要注意的是，块末尾的提交不需要 FCRC。

## 元数据标签

在 littlefs 中，32 位的标签用于描述每种类型的元数据。这意味着**所有**类型的元数据，包括文件条目、目录字段和全局状态，都有自己的标签。甚至用于标记提交结束的 CRC 也有自己的标签。

因此，标签格式包含了一些高度压缩的信息。需要注意的是，标签的类型分为多个层次，每个层次进一步分解为更多信息：

```
[----            32             ----]
[1|--  11   --|--  10  --|--  10  --]
 ^.     ^     .     ^          ^- length
 |.     |     .     '------------ id
 |.     '-----.------------------ type (type3)
 '.-----------.------------------ valid bit
  [-3-|-- 8 --]
    ^     ^- chunk
    '------- type (type1)
```

在进一步讨论之前，有一个重要的事情需要注意。这些标签**不是**以小端序存储的。提交中的标签实际上是以大端序存储的（这也是 littlefs 中唯一以大端序存储的内容）。这一点看似奇怪，但原因是有效位必须是提交中的第一个位，而在转换为小端序时，有效位会出现在第 4 个字节中。我们可以重新设计标签结构，将有效位放在较低的位置，但由于所有字段都不是字节对齐的，这样做会比直接以大端序存储标签更加复杂。

另外需要注意的是，标签 `0x00000000` 和 `0xffffffff` 都是无效的，可以用于表示空值。

元数据标签字段：

1. **Valid bit (1-bit)** -  指示标签是否有效。

2. **Type3 (11-bits)** - 标签的类型。该字段进一步分解为一个 3 位的抽象类型和一个 8 位的块字段。需要注意的是，值 `0x000` 是无效的，没有分配类型。
   
    1. **Type1 (3-bits)** -  标签的抽象类型。将标签分为 8 个类别，便于进行位掩码查找。
       
     2. **Chunk (8-bits)** -块字段，由不同的抽象类型用于各种目的。type1 + chunk + id 构成了元数据块中每个标签的唯一标识符。
   
3. **Id (10-bits)** - 与标签关联的文件 id。元数据块中的每个文件都有一个唯一的 id，用于将标签与该文件关联。特殊值 `0x3ff` 用于与文件无关的标签，例如目录和全局元数据。
   
4. **Length (10-bits)** - 数据的长度（以字节为单位）。特殊值 `0x3ff` 表示该标签已被删除。

## 元数据类型

以下是 littlefs 中所有元数据的详尽列表。

---

#### `0x401` LFS_TYPE_CREATE

使用此 id 创建一个新文件。需要注意的是，元数据块中的文件不一定需要创建标签。创建标签的作用是将使用此 id 的文件移动到其他位置。从这个意义上说，创建标签类似于插入到一个假想的文件数组中。

创建和删除标签使 littlefs 能够按文件名按字母顺序对目录中的文件进行排序。

---

#### `0x4ff` LFS_TYPE_DELETE

删除具有此 id 的文件。与创建标签相反，此标签将相邻的文件移动到其他位置，类似于从假想的文件数组中删除。

---

#### `0x0xx` LFS_TYPE_NAME

将 id 与文件名和文件类型关联。

数据包含以 ASCII 字符串存储的文件名（未来可能会扩展为 UTF8）。

此标签中的块字段表示一个 8 位的文件类型，可以是以下之一。

目前，名称标签必须位于与 id 关联的任何其他标签之前，并且不能在不删除文件的情况下重新分配。

名称标签的布局：

```
        tag                          data
[--      32      --][---        variable length        ---]
[1| 3| 8 | 10 | 10 ][---          (size * 8)           ---]
 ^  ^  ^    ^    ^- size                   ^- file name
 |  |  |    '------ id
 |  |  '----------- file type
 |  '-------------- type1 (0x0)
 '----------------- valid bit
```

名称字段:

1. **file type (8-bits)** - 文件的类型。

2. **file name** - 以 ASCII 字符串存储的文件名。

---
#### `0x001` LFS_TYPE_REG

将 id + 名称初始化为常规文件。

每个文件的存储方式取决于其结构标签，如下所述。

------

#### `0x002` LFS_TYPE_DIR

将 id + 名称初始化为目录。

littlefs 中的目录在磁盘上存储为元数据对的链表，每个对包含按字母顺序排列的任意数量的文件。指向目录的指针存储在结构标签中，如下所述。

------

#### `0x0ff` LFS_TYPE_SUPERBLOCK

将 id 初始化为超级块条目。

超级块条目是一个特殊条目，用于存储格式化时的配置并标识文件系统。

名称有点误导性。虽然超级块条目与其他文件系统中的超级块具有相同的用途，但在 littlefs 中，超级块没有专用的块。相反，超级块条目在根植于块 0 和 1 的元数据对链表中重复存储。最后一个元数据对同时作为文件系统的根目录。

```
 .--------.  .--------.  .--------.  .--------.  .--------.
.| super  |->| super  |->| super  |->| super  |->| file B |
|| block  | || block  | || block  | || block  | || file C |
||        | ||        | ||        | || file A | || file D |
|'--------' |'--------' |'--------' |'--------' |'--------'
'--------'  '--------'  '--------'  '--------'  '--------'

\----------------+----------------/ \----------+----------/
          superblock pairs               root directory
```

文件系统最初只包含根目录。每次根对压缩时，超级块元数据对都会增长，以指数级延长设备的使用寿命。

超级块条目的内容存储在一个带有超级块类型的名称标签和一个内联结构标签中。名称标签包含魔数字符串 "littlefs"，而内联结构标签包含版本和配置信息。

超级块名称标签和内联结构标签的布局：

```
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][---              64               ---]
 ^    ^     ^    ^- size (8)           ^- magic string ("littlefs")
 |    |     '------ id (0)
 |    '------------ type (0x0ff)
 '----------------- valid bit

        tag                          data
[--      32      --][--      32      --|--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --|--      32      --]
 ^    ^     ^    ^            ^- version         ^- block size      ^- block count
 |    |     |    |  [--      32      --|--      32      --|--      32      --]
 |    |     |    |  [--      32      --|--      32      --|--      32      --]
 |    |     |    |            ^- name max        ^- file max        ^- attr max
 |    |     |    '- size (24)
 |    |     '------ id (0)
 |    '------------ type (0x201)
 '----------------- valid bit
```

超级块字段:

1. **Magic string (8-bytes)** - 表示设备上存在 littlefs 的魔数字符串。必须是字符串 "littlefs"

2. **Version (32-bits)** - 格式化时 littlefs 的版本。版本编码为一个 32 位的值，高 16 位包含主版本号，低 16 位包含次版本号。
   
   本规范描述的是版本 2.0 (`0x00020000`)。

3. **Block size (32-bits)** -  文件系统使用的逻辑块大小（以字节为单位）。

4. **Block count (32-bits)** - 文件系统中的块数量。

5. **Name max (32-bits)** - 文件名的最大大小（以字节为单位）。

6. **File max (32-bits)** - 文件的最大大小（以字节为单位）。

7. **Attr max (32-bits)** - 文件属性的最大大小（以字节为单位）。

超级块必须始终是元数据对中的第一个条目（id 0），并且名称标签必须始终是元数据对中的第一个标签。这使得魔数字符串 "littlefs" 在有效的 littlefs 超级块中始终位于偏移量=8 的位置。

---
#### `0x2xx` LFS_TYPE_STRUCT

将 id 与一个磁盘上的数据结构关联。

数据的具体布局取决于存储在块字段中的数据结构类型，可以是以下之一。

任何类型的结构都会取代与该 id 关联的所有其他结构。例如，追加一个 ctz 结构会替换同一文件上的内联结构。

------

#### `0x200` LFS_TYPE_DIRSTRUCT

为 id 提供一个目录数据结构。

littlefs 中的目录在磁盘上存储为元数据对的链表，每个对包含按字母顺序排列的任意数量的文件。

```
     |
     v
 .--------.  .--------.  .--------.  .--------.  .--------.  .--------.
.| file A |->| file D |->| file G |->| file I |->| file J |->| file M |
|| file B | || file E | || file H | ||        | || file K | || file N |
|| file C | || file F | ||        | ||        | || file L | ||        |
|'--------' |'--------' |'--------' |'--------' |'--------' |'--------'
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
```

dir-struct 标签仅包含指向目录中第一个元数据对的指针。如果不遍历目录，目录的大小是未知的。

指向目录中下一个元数据对的指针存储在尾标签中，如下所述。

dir-struct 标签的布局：

```
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][---              64               ---]
 ^    ^     ^    ^- size (8)           ^- metadata pair
 |    |     '------ id
 |    '------------ type (0x200)
 '----------------- valid bit
```

1. Dir-struct 字段：
   
   1. **Metadata pair (8-bytes)** - 指向目录中第一个元数据对的指针。

---
#### `0x201` LFS_TYPE_INLINESTRUCT

为 id 提供一个内联数据结构。

内联结构用于存储可以放入元数据对中的小文件。在这种情况下，文件数据直接存储在标签的数据区域中。

内联结构标签的布局：

```
        tag                          data
[--      32      --][---        variable length        ---]
[1|- 11 -| 10 | 10 ][---           (size * 8)          ---]
 ^    ^     ^    ^- size                    ^- inline data
 |    |     '------ id
 |    '------------ type (0x201)
 '----------------- valid bit
```

内联结构字段：

1. **内联数据** - 直接存储在元数据对中的文件数据。

------

#### `0x202` LFS_TYPE_CTZSTRUCT

为 id 提供一个 CTZ 跳表数据结构。

CTZ 跳表用于存储无法放入元数据对中的文件。这些文件以反向跳表的形式存储，并带有一个指向跳表头部的指针。需要注意的是，跳表头部和文件大小足以读取文件。

CTZ 跳表的具体工作原理有些复杂。完整的解释可以在 [DESIGN.md](https://chat.deepseek.com/a/chat/s/DESIGN.md#ctz-skip-lists) 中找到。

简要总结：对于每个第 *n* 个块，其中 *n* 能被 2‍*ˣ* 整除，该块包含一个指向块 *n*-2‍*ˣ* 的指针。这些指针按 *x* 的递增顺序存储在文件的每个块中，位于实际数据之前。

```
                                                               |
                                                               v
.--------.  .--------.  .--------.  .--------.  .--------.  .--------.
| A      |<-| D      |<-| G      |<-| J      |<-| M      |<-| P      |
| B      |<-| E      |--| H      |<-| K      |--| N      |  | Q      |
| C      |<-| F      |--| I      |--| L      |--| O      |  |        |
'--------'  '--------'  '--------'  '--------'  '--------'  '--------'
  block 0     block 1     block 2     block 3     block 4     block 5
              1 skip      2 skips     1 skip      3 skips     1 skip
```

需要注意的是，块中指针的最大数量受文件最大大小除以块大小的限制。对于 32 位的文件大小，这导致最小块大小为 104 字节。

CTZ 结构标签的布局

```
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --]
 ^    ^     ^    ^            ^                  ^- file size
 |    |     |    |            '-------------------- file head
 |    |     |    '- size (8)
 |    |     '------ id
 |    '------------ type (0x202)
 '----------------- valid bit
```

CTZ 结构字段

1. **File head (32-bits)** - 指向文件 CTZ 跳表头部的块的指针。
   
2. **File size (32-bits)** - 文件的大小（以字节为单位）。

---
#### `0x3xx` LFS_TYPE_USERATTR

将用户属性附加到 id 上。

littlefs 有一个“用户属性”的概念。这些是用户提供的小属性，可用于存储时间戳、哈希值、权限等信息。

每个用户属性由一个 8 位的类型唯一标识，该类型存储在块字段中，而用户属性本身可以在标签的数据中找到。

目前没有标准的用户属性，一个可移植的 littlefs 实现应该能够在缺少任何用户属性的情况下正常工作。

用户属性标签的布局：

```
        tag                          data
[--      32      --][---        variable length        ---]
[1| 3| 8 | 10 | 10 ][---           (size * 8)          ---]
 ^  ^  ^    ^    ^- size                    ^- attr data
 |  |  |    '------ id
 |  |  '----------- attr type
 |  '-------------- type1 (0x3)
 '----------------- valid bit
```

用户属性字段：

1. **属性类型（8 位）** - 用户属性的类型。
2. **属性数据** - 与用户属性关联的数据。

------

#### `0x6xx` LFS_TYPE_TAIL

为元数据对本身提供尾指针。

元数据对的尾指针在 littlefs 中用于包含所有元数据对的链表。块字段包含尾部的类型，指示下一个元数据对是目录的一部分（硬尾）还是仅用于遍历文件系统（软尾）。

```
         .--------.
        .| dir A  |-.
        ||softtail| |
.--------|        |-'
|       |'--------'
|       '---|--|-'
|        .-'    '-------------.
|       v                      v
|  .--------.  .--------.  .--------.
'->| dir B  |->| dir B  |->| dir C  |
  ||hardtail| ||softtail| ||        |
  ||        | ||        | ||        |
  |'--------' |'--------' |'--------'
  '--------'  '--------'  '--------'
```

目前，任何类型的尾部都会取代元数据对中前面的其他尾部，但如果添加了额外的元数据对状态，这可能会发生变化。

关于元数据对链表的说明：通常情况下，此链表包含文件系统中的每个元数据对。然而，某些操作可能会导致在发生断电时此链表不同步。当发生这种情况时，littlefs 会在全局状态中设置“同步”标志。该标志的具体存储方式如下所述。

当同步标志被设置时：

1. 链表中可能包含一个在文件系统中已被移除的孤立目录。
2. 链表中可能包含一个在文件系统中已被替换的坏块元数据对。

如果同步标志被设置，则必须在使用链表之前检查线程链表是否存在这些错误。需要注意的是，如果 littlefs 以只读方式挂载，则可以忽略线程链表。

尾部标签的布局：

```
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1| 3| 8 | 10 | 10 ][---              64               ---]
 ^  ^  ^   ^    ^- size (8)            ^- metadata pair
 |  |  |   '------ id
 |  |  '---------- tail type
 |  '------------- type1 (0x6)
 '---------------- valid bit
```

尾部字段：

1. **Tail type (8-bits)** - 尾指针的类型。

2. **Metadata pair (8-bytes)** - 指向下一个元数据对的指针。

---
#### `0x600` LFS_TYPE_SOFTTAIL

提供一个指向文件系统中下一个元数据对的尾指针。

在这种情况下，下一个元数据对不属于当前目录，仅在遍历整个文件系统时才应跟随。

---

#### `0x601` LFS_TYPE_HARDTAIL

提供一个指向目录中下一个元数据对的尾指针。

在这种情况下，下一个元数据对属于当前目录。需要注意的是，由于 littlefs 中的目录是按字母顺序排序的，下一个元数据对应仅包含比当前对中任何文件名更大的文件名。

---

#### `0x7xx` LFS_TYPE_GSTATE

提供全局状态条目的增量位。

littlefs 有一个“全局状态”的概念。这是一小部分状态，可以通过提交到文件系统中的**任何**元数据对来更新。

其工作原理是，全局状态存储为一组分布在文件系统中的增量，通过这些增量的异或和可以找到全局状态。

```
 .--------.  .--------.  .--------.  .--------.  .--------.
.|        |->| gdelta |->|        |->| gdelta |->| gdelta |
||        | || 0x23   | ||        | || 0xff   | || 0xce   |
||        | ||        | ||        | ||        | ||        |
|'--------' |'--------' |'--------' |'--------' |'--------'
'--------'  '----|---'  '--------'  '----|---'  '----|---'
                 v                       v           v
       0x00 --> xor ------------------> xor ------> xor --> gstate = 0x12
```

需要注意的是，以这种方式存储全局状态在存储使用方面非常昂贵，因此任何全局状态都应保持非常小。

每个全局状态的大小和格式取决于类型，该类型存储在块字段中。目前，唯一的全局状态是移动状态，如下所述。

---

#### `0x7ff` LFS_TYPE_MOVESTATE

提供全局移动状态的增量位。

littlefs 中的移动状态用于存储有关可能导致文件系统在断电时不同步的操作信息。可能发生这种情况的操作包括在元数据对之间移动文件以及任何更改线程链表中元数据对的操作。

在移动的情况下，移动状态包含一个标签 + 元数据对，用于描述正在进行的移动的源。如果此标签非零，则意味着在移动过程中发生了断电，文件存在于两个不同的位置。如果发生这种情况，应认为移动的源已被删除，并且应在对文件系统进行任何其他写操作之前完成移动（删除源）。

在对线程链表进行操作的情况下，使用一个“同步”位来指示正在进行修改。如果设置了此同步标志，则在使用线程链表之前需要检查错误。需要检查的具体情况在上面的尾部标签中已描述。

移动状态的布局：

```
        tag                                    data
[--      32      --][--      32      --|--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][1|- 11 -| 10 | 10 |---              64               ---]
 ^    ^     ^    ^   ^    ^     ^    ^- padding (0)       ^- metadata pair
 |    |     |    |   |    |     '------ move id
 |    |     |    |   |    '------------ move type
 |    |     |    |   '----------------- sync bit
 |    |     |    |
 |    |     |    '- size (12)
 |    |     '------ id (0x3ff)
 |    '------------ type (0x7ff)
 '----------------- valid bit
```

移动状态字段：

1. **Sync bit (1-bit)** -  指示元数据对线程链表是否同步。如果设置，应检查线程链表是否存在错误。
   
2. **Move type (11-bits)** -  正在执行的移动类型。必须为 `0x000`，表示没有移动，或 `0x4ff` 表示应删除源文件。**Move id (10-bits)** -正在移动的文件 id。
   
3. **Metadata pair (8-bytes)** -  指向包含移动的元数据对的指针。

---
#### `0x5xx` LFS_TYPE_CRC

最后但同样重要的是，CRC 标签标记了提交的结束，并为元数据块的任何提交提供了校验和。

数据的前 32 位包含一个 CRC-32，多项式为 `0x04c11db7`，初始值为 `0xffffffff`。此 CRC 提供了自上一个 CRC 标签以来所有元数据的校验和，包括 CRC 标签本身。对于第一次提交，这包括元数据块的修订计数。

然而，数据的大小不仅限于 32 位。数据字段可能更大，以便将提交填充到下一个编程对齐的边界。

此外，CRC 标签的块字段包含一组标志，可以更改提交的行为。目前唯一使用的标志是最低位，它决定了任何后续标签的有效位的预期状态。这用于确保元数据块中未写入的存储将被检测为无效。

CRC 标签的布局：

```
        tag                                    data
[--      32      --][--      32      --|---        variable length        ---]
[1| 3| 8 | 10 | 10 ][--      32      --|---        (size * 8 - 32)        ---]
 ^  ^  ^    ^    ^            ^- crc                             ^- padding
 |  |  |    |    '- size
 |  |  |    '------ id (0x3ff)
 |  |  '----------- valid state
 |  '-------------- type1 (0x5)
 '----------------- valid bit
```

CRC 字段:

1. **Valid state (1-bit)** -  指示下一个提交中任何标签的有效位的预期值。
   
2. **CRC (32-bits)** - CRC-32，多项式为 `0x04c11db7`，初始值为 `0xffffffff`。
   
3. **Padding** - 填充到下一个编程对齐的边界。不保证填充内容。

---
#### `0x5ff` LFS_TYPE_FCRC

在 lfs2.1 中添加的可选 FCRC 标签包含在擦除时对下一个提交中某些字节的校验和。这使我们能够确保我们只对已擦除的字节进行编程，即使之前的提交因断电而失败。

在编程提交时，FCRC 大小必须至少与编程块大小一样大。然而，编程块不会保存在磁盘上，并且可以在挂载之间更改，因此磁盘上的 FCRC 大小可能与当前的编程块大小不同。

如果 FCRC 缺失或校验和不匹配，我们必须假设尝试了一个提交但由于断电而失败。

FCRC 标签的布局：

```
        tag                          data
[--      32      --][--      32      --|--      32      --]
[1|- 11 -| 10 | 10 ][--      32      --|--      32      --]
 ^    ^     ^    ^            ^- fcrc size       ^- fcrc
 |    |     |    '- size (8)
 |    |     '------ id (0x3ff)
 |    '------------ type (0x5ff)
 '----------------- valid bit
```

2. FCRC 字段：
   1. **FCRC size（32 位）** - 此提交的 CRC 标签填充后要包含在 FCRC 中的字节数。
   2. **FCRC（32 位）** - 此提交的 CRC 标签填充后在擦除时的字节的 CRC。与 CRC 标签一样，这使用 CRC-32，多项式为 `0x04c11db7`，初始值为 `0xffffffff`。

---
